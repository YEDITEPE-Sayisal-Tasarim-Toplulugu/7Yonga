`timescale 1ns / 1ps

module timer_tb;
    // Clock and reset signals
    logic        s_axi_aclk;
    logic        s_axi_aresetn;
    
    // AXI4-Lite Slave Interface
    // Write Address Channel
    logic [31:0] s_axi_awaddr;
    logic        s_axi_awvalid;
    logic        s_axi_awready;
    
    // Write Data Channel
    logic [31:0] s_axi_wdata;
    logic [3:0]  s_axi_wstrb;
    logic        s_axi_wvalid;
    logic        s_axi_wready;
    
    // Write Response Channel
    logic [1:0]  s_axi_bresp;
    logic        s_axi_bvalid;
    logic        s_axi_bready;
    
    // Read Address Channel
    logic [31:0] s_axi_araddr;
    logic        s_axi_arvalid;
    logic        s_axi_arready;
    
    // Read Data Channel
    logic [31:0] s_axi_rdata;
    logic [1:0]  s_axi_rresp;
    logic        s_axi_rvalid;
    logic        s_axi_rready;
    
    // Register addresses
    localparam TIM_PRE = 8'h00; // Prescaler register
    localparam TIM_ARE = 8'h04; // Auto-reload register
    localparam TIM_CLR = 8'h08; // Clear register
    localparam TIM_ENA = 8'h0C; // Enable register
    localparam TIM_MOD = 8'h10; // Mode register
    localparam TIM_CNT = 8'h14; // Counter register
    localparam TIM_EVN = 8'h18; // Event register
    localparam TIM_EVC = 8'h1C; // Event clear register
    
    // Instance of the timer module
    timer dut (
        .s_axi_aclk    (s_axi_aclk),
        .s_axi_aresetn (s_axi_aresetn),
        
        .s_axi_awaddr  (s_axi_awaddr),
        .s_axi_awvalid (s_axi_awvalid),
        .s_axi_awready (s_axi_awready),
        
        .s_axi_wdata   (s_axi_wdata),
        .s_axi_wstrb   (s_axi_wstrb),
        .s_axi_wvalid  (s_axi_wvalid),
        .s_axi_wready  (s_axi_wready),
        
        .s_axi_bresp   (s_axi_bresp),
        .s_axi_bvalid  (s_axi_bvalid),
        .s_axi_bready  (s_axi_bready),
        
        .s_axi_araddr  (s_axi_araddr),
        .s_axi_arvalid (s_axi_arvalid),
        .s_axi_arready (s_axi_arready),
        
        .s_axi_rdata   (s_axi_rdata),
        .s_axi_rresp   (s_axi_rresp),
        .s_axi_rvalid  (s_axi_rvalid),
        .s_axi_rready  (s_axi_rready)
    );
    
    // Clock generation
    initial begin
        s_axi_aclk = 1'b0;
        forever #5 s_axi_aclk = ~s_axi_aclk; // 100MHz clock
    end
    
    // Tasks for AXI4-Lite transactions
    
    // AXI4-Lite write transaction
    task axi_write(input [31:0] addr, input [31:0] data);
        // Address phase
        s_axi_awaddr  <= addr;
        s_axi_awvalid <= 1'b1;
        s_axi_wdata   <= data;
        s_axi_wstrb   <= 4'hF; // Write all bytes
        s_axi_wvalid  <= 1'b1;
        s_axi_bready  <= 1'b1;
        
        wait(s_axi_awready && s_axi_wready);
        @(posedge s_axi_aclk);
        
        // Clear valid signals after handshake
        s_axi_awvalid <= 1'b0;
        s_axi_wvalid  <= 1'b0;
        
        // Response phase
        wait(s_axi_bvalid);
        @(posedge s_axi_aclk);
        s_axi_bready <= 1'b0;
        
        // Check response
        if (s_axi_bresp != 2'b00) begin
            $display("ERROR: AXI write response error at time %t", $time);
        end
        
        $display("AXI Write: Addr=0x%h, Data=0x%h at time %t", addr, data, $time);
    endtask
    
    // AXI4-Lite read transaction
    task axi_read(input [31:0] addr, output [31:0] data);
        // Address phase
        s_axi_araddr  <= addr;
        s_axi_arvalid <= 1'b1;
        s_axi_rready  <= 1'b1;
        
        wait(s_axi_arready);
        @(posedge s_axi_aclk);
        
        // Clear valid signal after handshake
        s_axi_arvalid <= 1'b0;
        
        // Data phase
        wait(s_axi_rvalid);
        data = s_axi_rdata;
        @(posedge s_axi_aclk);
        s_axi_rready <= 1'b0;
        
        // Check response
        if (s_axi_rresp != 2'b00) begin
            $display("ERROR: AXI read response error at time %t", $time);
        end
        
        $display("AXI Read: Addr=0x%h, Data=0x%h at time %t", addr, data, $time);
    endtask
    
    // Task to wait for a specific number of clock cycles
    task wait_cycles(input int cycles);
        repeat(cycles) @(posedge s_axi_aclk);
    endtask
    
    // Test sequence
    initial begin
        // Initialize signals
        s_axi_aresetn  = 1'b0;
        s_axi_awvalid  = 1'b0;
        s_axi_wvalid   = 1'b0;
        s_axi_bready   = 1'b0;
        s_axi_arvalid  = 1'b0;
        s_axi_rready   = 1'b0;
        
        // Apply reset
        #20;
        s_axi_aresetn = 1'b1;
        #20;
        
        // Test 1: Test prescaler and counter in up-counting mode
        $display("\n--- Test 1: Timer in Up-counting mode ---");
        
        // Set prescaler to 2 (count every 3 clock cycles)
        axi_write(TIM_PRE, 32'd2);
        
        // Set auto-reload value to 5
        axi_write(TIM_ARE, 32'd5);
        
        // Set up-counting mode (TIM_MOD[0] = 1)
        axi_write(TIM_MOD, 32'd1);
        
        // Enable timer (TIM_ENA[0] = 1)
        axi_write(TIM_ENA, 32'd1);
        
        // Wait for counter to increment
        wait_cycles(4);
        
        // Read counter value
        begin
            logic [31:0] cnt_val;
            axi_read(TIM_CNT, cnt_val);
            
            // Counter should be 1 after 3*1 = 3 clock cycles
            if (cnt_val !== 32'd1) begin
                $display("ERROR: Counter value incorrect. Expected 1, got %d", cnt_val);
            end else begin
                $display("SUCCESS: Counter value is correctly at 1");
            end
        end
        
        // Wait for more cycles to see auto-reload in action
        wait_cycles(30);
        
        // Read counter value and event counter
        begin
            logic [31:0] cnt_val, evn_val;
            axi_read(TIM_CNT, cnt_val);
            axi_read(TIM_EVN, evn_val);
            
            // Counter should have wrapped around at least once
            $display("Counter value after 30 cycles: %d", cnt_val);
            $display("Event counter value: %d", evn_val);
            
            if (evn_val == 0) begin
                $display("ERROR: Event counter didn't increment on auto-reload");
            end else begin
                $display("SUCCESS: Event counter incremented to %d", evn_val);
            end
        end
        
        // Test 2: Clear counter
        $display("\n--- Test 2: Clear counter ---");
        
        // Clear the counter
        axi_write(TIM_CLR, 32'd1);
        
        // Read counter value
        begin
            logic [31:0] cnt_val;
            axi_read(TIM_CNT, cnt_val);
            
            // Counter should be 0 after clear
            if (cnt_val !== 32'd0) begin
                $display("ERROR: Counter not cleared properly. Expected 0, got %d", cnt_val);
            end else begin
                $display("SUCCESS: Counter cleared to 0");
            end
        end
        
        // Test 3: Disable timer
        $display("\n--- Test 3: Disable timer ---");
        
        // Disable timer
        axi_write(TIM_ENA, 32'd0);
        
        // Wait enough cycles for counter to increment if it were enabled
        wait_cycles(15);
        
        // Read counter value
        begin
            logic [31:0] cnt_val;
            axi_read(TIM_CNT, cnt_val);
            
            // Counter should still be 0 as timer is disabled
            if (cnt_val !== 32'd0) begin
                $display("ERROR: Counter incremented while disabled. Expected 0, got %d", cnt_val);
            end else begin
                $display("SUCCESS: Counter remained at 0 while disabled");
            end
        end
        
        // Test 4: Down-counting mode
        $display("\n--- Test 4: Down-counting mode ---");
        
        // Set down-counting mode (TIM_MOD[0] = 0)
        axi_write(TIM_MOD, 32'd0);
        
        // Set counter value to auto-reload value
        axi_write(TIM_CLR, 32'd1); // Clear counter first
        axi_write(TIM_ENA, 32'd1); // Enable timer
        
        // Wait for counter to be loaded with auto-reload value
        wait_cycles(1);
        
        // Read counter value
        begin
            logic [31:0] cnt_val;
            axi_read(TIM_CNT, cnt_val);
            
            // In down-counting mode, counter starts from auto-reload value
            if (cnt_val !== 32'd5) begin
                $display("ERROR: Counter not loaded with auto-reload value. Expected 5, got %d", cnt_val);
            end else begin
                $display("SUCCESS: Counter loaded with auto-reload value 5 in down-counting mode");
            end
        end
        
        // Wait for counter to decrement
        wait_cycles(3);
        
        // Read counter value
        begin
            logic [31:0] cnt_val;
            axi_read(TIM_CNT, cnt_val);
            
            // After 3 clock cycles with prescaler=2, counter should have decremented once
            if (cnt_val !== 32'd4) begin
                $display("ERROR: Counter did not decrement correctly. Expected 4, got %d", cnt_val);
            end else begin
                $display("SUCCESS: Counter decremented correctly to 4");
            end
        end
        
        // Test 5: Event counter clear
        $display("\n--- Test 5: Event counter clear ---");
        
        // Let the counter wrap around a few times
        wait_cycles(50);
        
        // Read event counter
        begin
            logic [31:0] evn_val;
            axi_read(TIM_EVN, evn_val);
            $display("Event counter value before clear: %d", evn_val);
        end
        
        // Clear event counter
        axi_write(TIM_EVC, 32'd1);
        
        // Read event counter after clear
        begin
            logic [31:0] evn_val;
            axi_read(TIM_EVN, evn_val);
            
            if (evn_val !== 32'd0) begin
                $display("ERROR: Event counter not cleared. Expected 0, got %d", evn_val);
            end else begin
                $display("SUCCESS: Event counter cleared to 0");
            end
        end
        
        $display("\n--- All Timer Tests Completed ---");
        #100;
        $finish;
    end
    
    // Monitor counter value
    initial begin
        $monitor("Time=%t, Counter=%d, Events=%d", 
                $time, 
                dut.tim_cnt_reg, 
                dut.tim_evn_reg);
    end
endmodule