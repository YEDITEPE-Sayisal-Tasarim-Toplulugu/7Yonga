# Copyright 2025 Yeditepe Üniversitesi Sayısal Tasarım Topluluğu.
# Copyright and related rights are licensed under the Solderpad Hardware
# License, Version 0.51 (the "License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
# or agreed to in writing, software, hardware and materials distributed under
# this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.

import argparse
import math
import re

NAME        = 'Teknofest ~ BOOT Code Generator v1.0'
NAME_TEMP   = 'generated by Teknofest ~ BOOT Code Generator v1.0'

def fill_template(content: str, replacements: dict) -> str:
    """
    Bir şablon içindeki %VARNAME% biçimindeki değişkenleri verilen
    sözlükteki değerlerle değiştirir. Değiştirilmiş içerik döndürülür.

    Args:
        template_path (str): Şablon metni (örnek: 'metin%A%').
        replacements (dict): Değiştirilecek değişkenler (örnek: {'MEMORY_ADDR_WIDTH': '10'}).

    Returns:
        str: Güncellenmiş şablon içeriği.
    """

    # Şablondaki tüm %VARNAME% türü placeholder'ları bul
    placeholders = set(re.findall(r'%([A-Z0-9_]+)%', content))

    # Eksik olanları kontrol et
    missing_keys = placeholders - replacements.keys()
    if missing_keys:
        raise ValueError(f"Eksik değişkenler: {', '.join(missing_keys)}")

    for key, value in replacements.items():
        placeholder = f"%{key}%"
        content = content.replace(placeholder, str(value))

    return content

def bin_To_hex(filen_name : str) -> list:
    hexdFile_op = []
    binFile_op = open(filen_name, "rb")
    binData = binFile_op.read()
    
    i=0
    while (i < len(binData)):
        dat = binData[i : i+4]
        dst = "%02x%02x%02x%02x\n" % ((dat[3] if (len(dat) > 3) else 0), (dat[2] if (len(dat) > 2) else 0), (dat[1] if (len(dat) > 1) else 0), dat[0])
        hexdFile_op.append(dst)
        i+=4

    return hexdFile_op

def generateRomData(hex_lst : list, data_size : int, data_format : str) -> str:
    retstr = ""
    for hl in hex_lst[:-1]:
        hl = hl.replace("\n", "")
        retstr += f"{data_size}'{data_format}{hl},\n"
    else:
        retstr += f"{data_size}'{data_format}{hex_lst[-1].replace("\n", "")}"

    return retstr


parser = argparse.ArgumentParser(description=NAME)
parser.add_argument('--version', action='version', version=NAME)
parser.add_argument('--bin', dest='bin_data_file', type=str, help='BIN data file includes program data')
parser.add_argument('--template', dest='template_file', type=str, help='Template file')
parser.add_argument('--o', dest='out_file', type=str, help='output file')
parser.add_argument('--mwidth', dest='mwidth', type=str, default='32', help='memory width default 32')

args = parser.parse_args()
hex_data_file_name = args.bin_data_file
template_file_name = args.template_file
out_file_name = args.out_file
mwidth = args.mwidth

hex_data_file = bin_To_hex(hex_data_file_name)

with open(template_file_name, "r", encoding="utf-8") as template_file:
    template_file_data = template_file.read()

rom_depth = len(hex_data_file)
rom_addr_width = int(math.ceil(math.log2(rom_depth)))

format = {
    "COP"               : str(NAME_TEMP),
    "MEMORY_ADDR_WIDTH" : str(rom_addr_width),
    "MEMORY_DEPTH"      : str(rom_depth),
    "MEMORY_WIDTH"      : str(mwidth),
    "BOOT_CODE"         : generateRomData(hex_data_file, mwidth, "h"),
}

edited_template = fill_template(template_file_data, format)

with open(out_file_name, 'w', encoding='utf-8') as out_file:
    out_file.write(edited_template)
